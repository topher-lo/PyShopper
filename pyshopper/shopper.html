<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyshopper.shopper API documentation</title>
<meta name="description" content="This module contains the `Shopper` class that implements
Shopper, a probablistic model of shopping baskets, from the paper: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyshopper.shopper</code></h1>
</header>
<section id="section-intro">
<p>This module contains the <code><a title="pyshopper.shopper.Shopper" href="#pyshopper.shopper.Shopper">Shopper</a></code> class that implements
Shopper, a probablistic model of shopping baskets, from the paper:</p>
<ul>
<li>Francisco J. R. Ruiz, Susan Athey, David M. Blei. SHOPPER:
A Probabilistic Model of Consumer Choice with Substitutes and Complements.
ArXiv 1711.03560. 2017.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module contains the `Shopper` class that implements
Shopper, a probablistic model of shopping baskets, from the paper:

+ Francisco J. R. Ruiz, Susan Athey, David M. Blei. SHOPPER:
A Probabilistic Model of Consumer Choice with Substitutes and Complements.
ArXiv 1711.03560. 2017.
&#34;&#34;&#34;

import arviz as az
import logging
import numpy as np
import theano
import pandas as pd
import pymc3 as pm
import seaborn as sns

import theano.tensor as tt

from sklearn import preprocessing
from matplotlib import pyplot as plt

from pymc3.variational.callbacks import CheckParametersConvergence


# Logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Set seaborn default theme
sns.set_theme()

# Global variables
DATA_PATH = &#39;data/train.tsv&#39;
PRICES_PATH = &#39;data/prices.tsv&#39;


def load_data(data_path: str = DATA_PATH, prices_path: str = PRICES_PATH):
    &#34;&#34;&#34;Extract, transforms, and loads data for Shopper.

    Args:
        data_path (str): 
            Shopping trips data.
            Path to .tsv file with four columns of data (without header)
            in the order of user_id, item_id, session_id, and quantity.
            Each row represents one trip.

        prices_path (str): 
            Prices data.
            Path to .tsv file with three columns of data (without header)
            in the order of item_id, session_id, and price.
            Each row represents the price per item per session.

    Returns:
        Joined Pandas DataFrame of shopping trips data and prices data.
    &#34;&#34;&#34;
    trips = pd.read_csv(data_path,
                        header=None,
                        names=[&#39;user_id&#39;, &#39;item_id&#39;, &#39;session_id&#39;, &#39;quantity&#39;],
                        sep=&#39;\t&#39;)
    prices = pd.read_csv(prices_path,
                         header=None,
                         names=[&#39;item_id&#39;, &#39;session_id&#39;, &#39;price&#39;],
                         sep=&#39;\t&#39;)
    data = pd.merge(trips, prices, on=[&#39;item_id&#39;, &#39;session_id&#39;])
    return data


def _prepare_data(data: pd.DataFrame):
    &#34;&#34;&#34;Prepare data for used in Shopper. Returns preprocessed
    data variables.
    &#34;&#34;&#34;
    # Prices
    prices = data[&#39;price&#39;]
    # Order
    order = data.groupby([&#39;user_id&#39;, &#39;session_id&#39;])[&#39;item_id&#39;]\
                .cumcount()
    # Scaling factor
    sf = (order.apply(lambda x: 1 / x if x &gt; 0 else 0)
               .to_numpy(dtype=&#39;float32&#39;))
    # Observations index
    obs_idx = (preprocessing.LabelEncoder()
                            .fit_transform(data.index)
                            .astype(&#39;int32&#39;))
    # Items
    items_idx = (preprocessing.LabelEncoder()
                              .fit_transform(data[&#39;item_id&#39;])
                              .astype(&#39;int32&#39;))
    # Users
    users_idx = (preprocessing.LabelEncoder()
                              .fit_transform(data[&#39;user_id&#39;])
                              .astype(&#39;int32&#39;))
    # Labels
    labels = (preprocessing.LabelEncoder()
                           .fit_transform(data[&#39;item_id&#39;])
                           .astype(&#39;int32&#39;))
    return {&#39;prices&#39;: prices,
            &#39;order&#39;: order,
            &#39;sf&#39;: sf,
            &#39;obs_idx&#39;: obs_idx,
            &#39;items_idx&#39;: items_idx,
            &#39;users_idx&#39;: users_idx,
            &#39;labels&#39;: labels}


class Shopper:
    &#34;&#34;&#34;Shopper implementation.

    Let T = number of trips; U = number of users;
    C = number of items; and W = number of weeks.

    Note: model currently only supports ordered baskets.

    Attributes:
        data (Pandas DataFrame): 
            Observed trips data (number of trips by 4).
            DataFrame with columns: user_id, item_id, session_id, and price.

        model (PyMC3 Model): 
            Shopper model.
    &#34;&#34;&#34;
    def __init__(self,
                 data: pd.DataFrame,
                 K: int = 50,
                 price_dim: int = 10,
                 price_dtype: str = &#39;float32&#39;,
                 rho_var: float = 1,
                 alpha_var: float = 1,
                 lambda_var: float = 1,
                 theta_var: float = 1,
                 delta_var: float = 0.01,
                 mu_var: float = 0.01,
                 gamma_rate: float = 1000,
                 gamma_shape: float = 100,
                 beta_rate: float = 1000,
                 beta_shape: float = 100):
        &#34;&#34;&#34;Intialises Shopper instance.

        Args:
            data (Pandas DataFrame): 
                Observed trips data (number of trips by 4).
                DataFrame with columns: user_id, item_id, session_id, 
                and price.

            K (int): 
                Number of latent factors for alpha_c, rho_c, and theta_u;
                defaults to 50.

            price_dim (int): 
                Number of latent factors for price vectors gamma_u and beta_c;
                defaults to 10.

            price_dtype (str): 
                The datatype used for prices; defaults to float32.

            rho_var (float): 
                Prior variance over rho_c; defaults to 1.

            alpha_var (float): 
                Prior variance over alpha_c; defaults to 1.

            theta_var (float): 
                Prior variance over theta_u; defaults to 1.

            lambda_var (float): 
                Prior variance over lambda_c; defaults to 1.

            delta_var (float): 
                Prior variance over delta_w; defaults to 0.01.

            mu_var (float): 
                Prior variance over mu_c; defaults to 0.01.

            gamma_rate (float): 
                Prior rate over gamma_u; defaults to 1000.

            gamma_shape (float): 
                Prior shape over gamma_u; defaults to 100.

            beta_rate (float): 
                Prior rate over beta_c; defaults to 1000.

            beta_shape (float): 
                Prior shape over beta_c; defaults to 100.
        &#34;&#34;&#34;
        # Set data
        self.data = data

        # Number of items
        C = data[&#39;item_id&#39;].nunique()
        # Number of users
        U = data[&#39;user_id&#39;].nunique()

        # Get preprocessed data variables
        data_vars = _prepare_data(data)

        logging.info(&#39;Building the Shopper model...&#39;)
        with pm.Model() as shopper:
            # Data
            prices = pm.Data(&#39;prices&#39;, data_vars[&#39;prices&#39;])
            order = pm.Data(&#39;order&#39;, data_vars[&#39;order&#39;])
            sf = pm.Data(&#39;sf&#39;, data_vars[&#39;sf&#39;])
            obs_idx = pm.Data(&#39;obs_idx&#39;, data_vars[&#39;obs_idx&#39;])
            items_idx = pm.Data(&#39;items_idx&#39;, data_vars[&#39;items_idx&#39;])
            users_idx = pm.Data(&#39;users_idx&#39;, data_vars[&#39;users_idx&#39;])
            labels = pm.Data(&#39;labels&#39;, data_vars[&#39;labels&#39;])

            # Latent variables
            # per item interaction coefficients
            rho_c = pm.Normal(&#39;rho_c&#39;,
                              mu=0,
                              sigma=rho_var,
                              shape=(C, K),
                              dtype=&#39;float32&#39;)
            # per item attributes
            alpha_c = pm.Normal(&#39;alpha_c&#39;,
                                mu=0,
                                sigma=alpha_var,
                                shape=(C, K),
                                dtype=&#39;float32&#39;)
            # per user preferences
            theta_u = pm.Normal(&#39;theta_u&#39;,
                                mu=0,
                                sigma=theta_var,
                                shape=(U, K),
                                dtype=&#39;float32&#39;)
            # per item popularity
            lambda_c = pm.Normal(&#39;lambda_c&#39;,
                                 mu=0,
                                 sigma=lambda_var,
                                 shape=C,
                                 dtype=&#39;float32&#39;)
            # per user price sensitivities
            gamma_u = pm.Gamma(&#39;gamma_u&#39;,
                               beta=gamma_rate,
                               alpha=gamma_shape,
                               shape=(U, price_dim),
                               dtype=&#39;float32&#39;)
            # per item price sensitivities
            beta_c = pm.Gamma(&#39;beta_c&#39;,
                              beta=beta_rate,
                              alpha=beta_shape,
                              shape=(C, price_dim),
                              dtype=&#39;float32&#39;)

            # Baseline utility per item per user:
            # Item popularity + Consumer Preferences - Price Effects
            # Note: variation comes from customer index and item prices
            psi_tc = tt.vector(&#39;psi_tc&#39;)
            psi_tc = lambda_c[items_idx] +\
                pm.math.dot(theta_u[users_idx], alpha_c[items_idx].T) -\
                pm.math.dot(gamma_u[users_idx], beta_c[items_idx].T) *\
                np.log(prices).astype(price_dtype)

            # sum^{i-1}_j [alpha_{y_tj}]
            def basket_items_attr(omega_prev, idx, alpha_c, order):
                # If first item in basket
                if tt.eq(order[idx], 0):
                    # No price-attributes interaction effects
                    omega_ti = tt.zeros(K)
                else:
                    omega_ti = omega_prev + alpha_c[idx-1]
                return omega_ti

            # omega_ti initial value
            omega_0 = tt.zeros(K)
            omega_ti = tt.vector(&#39;omega_ti&#39;)
            omega_ti, updates = theano.scan(fn=basket_items_attr,
                                            outputs_info=omega_0,
                                            non_sequences=[obs_idx,
                                                           alpha_c,
                                                           order],
                                            n_steps=obs_idx.shape[0])
            # Mean utility per basket per item
            Psi_tci = tt.vector(&#39;Psi_tci&#39;)
            Psi_tci = psi_tc + pm.math.dot(rho_c[items_idx],
                                           omega_ti[obs_idx-1].T)*sf[obs_idx]

            # Softmax likelihood p(y_ti = c | y_t0, y_t1, ..., y_ti-1)
            p = pm.Deterministic(&#39;p&#39;, tt.nnet.softmax(Psi_tci))
            y = pm.Categorical(&#39;y&#39;, p=p, observed=labels)

        logging.info(&#34;Done building the Shopper model.&#34;)
        # Set shopper to model attribute
        self.model = shopper

    def fit(self,
            N,
            method=&#39;ADVI&#39;,
            step=None,
            diff=&#39;relative&#39;,
            return_inferencedata=True,
            random_seed=42,
            **kwargs):
        &#34;&#34;&#34;Estimate parameters using Bayesian inference.
        Returns ShopperResults instance.

        Args:
            N (int): 
                Number of draws (MCMC) or iterations (ADVI).

            method (str): 
              - MCMC -- Monte Carlo Markov Chains
              - ADVI -- Automatic Differentiation Variational Inference

            diff (str): 
                Requires method to be ADVI. The difference type used
                to check convergence in the mean of the ADVI approximation

            step (function or iterable of functions):
                Requires method to be MCMC.
                A step function or collection of functions;
                defaults None (which uses the NUTS step method).

            return_inferencedata (bool): 
                Requires method to be MCMC.
                If True, returns arviz.InferenceData object.
                Otherwise, returns MultiTrace.InferenceData object.
                Defaults to True.

            random_seed (int): 
                Random seed; defaults to 42.
        &#34;&#34;&#34;
        model = self.model
        with model:
            if method == &#39;ADVI&#39;:
                callback = CheckParametersConvergence(diff=diff)
                res = pm.fit(n=N,
                             method=&#39;advi&#39;,
                             callbacks=[callback])
            else:
                res = pm.sample(draws=N,
                                step=step,
                                return_inferencedata=True,
                                random_seed=random_seed)
        return ShopperResults(model, res)


class ShopperResults:
    &#34;&#34;&#34;Results class for a fitted Shopper model.

    Attributes:
        model (PyMC3 Model): 
            Shopper model.

        res (PyMC3 results instance): 
            If MCMC, then requires arviz.InferenceData or
            MultiTrace.InferenceData. Else if ADVI, then
            requires pymc3.variational.opvi.Approximation.
    &#34;&#34;&#34;
    def __init__(self, model, res):
        self.model = model
        self.res = res

    def summary(self, **kwargs):
        &#34;&#34;&#34;Returns text-based output of common posterior statistics.

        Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
        to be set in kwargs if model was fitted with ADVI.
        &#34;&#34;&#34;
        res = self.res
        if &#39;variational&#39; in str(type(res)):
            logging.info(&#39;Sampling from posterior distribution...&#39;)
            trace = res.sample(draws=kwargs[&#39;draws&#39;])
            logging.info(&#39;Sampling complete.&#39;)
            logging.info(&#39;Computing posterior statistics...&#39;)
            summary = az.summary(trace, kind=&#39;stats&#39;)
        else:
            summary = az.summary(res)
        return summary

    def trace_plot(self, **kwargs):
        &#34;&#34;&#34;Returns the trace plot.

        Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
        to be set in kwargs if model was fitted with ADVI.
        &#34;&#34;&#34;
        res = self.res
        if &#39;variational&#39; in str(type(res)):
            logging.info(&#39;Sampling from posterior distribution...&#39;)
            trace = res.sample(draws=kwargs[&#39;draws&#39;])
            logging.info(&#39;Sampling complete.&#39;)
            plot = az.plot_trace(trace)
        else:
            plot = az.plot_trace(res)
        return plot

    def rhat(self):
        &#34;&#34;&#34;Returns the Gelman-Rubin statistic.

        Requires the Shopper model to be fitted with
        MCMC sampling.
        &#34;&#34;&#34;
        return az.summary(self.res)

    def energy_plot(self):
        &#34;&#34;&#34;Returns energy plot to check for convergence.
        Commonly used for high-dimensional models where it
        is too cumbersome to examine all parameter&#39;s traces.

        Requires the Shopper model to be fitted with
        MCMC sampling.
        &#34;&#34;&#34;
        return az.plot_energy(self.res)

    def elbo_plot(self):
        &#34;&#34;&#34;Returns trace plot of ADVI&#39;s objective function (ELBO).

        Requires the Shopper model to be fitted with ADVI.
        &#34;&#34;&#34;
        fig = plt.figure()
        plt.plot(self.res.hist)
        plt.ylabel(&#39;ELBO&#39;)
        plt.xlabel(&#39;n iterations&#39;)
        return fig

    def predict(self, data, random_seed=42, **kwargs):
        &#34;&#34;&#34;Returns predicted probabilities of outcomes for samples in X.
        &#34;&#34;&#34;
        model = self.model
        res = self.res
        data_vars = _prepare_data(data)
        with model:
            # Pass new values to model
            pm.set_data(data_vars)
            # Use the updated values and
            # predict outcomes and probabilities
            if &#39;variational&#39; in str(type(res)):
                logging.info(&#39;Sampling from posterior distribution...&#39;)
                trace = res.sample(draws=kwargs[&#39;draws&#39;])
                logging.info(&#39;Sampling complete.&#39;)
                posterior_predictive = pm.sample_posterior_predictive(
                    trace,
                    var_names=[&#39;y&#39;],
                    random_seed=random_seed
                )
            else:
                posterior_predictive = pm.sample_posterior_predictive(
                    res,
                    var_names=[&#39;y&#39;],
                    random_seed=random_seed
                )
        return posterior_predictive[&#39;y&#39;]

    def score(self, data):
        &#34;&#34;&#34;Returns the mean accuracy on the given test data and labels.
        &#34;&#34;&#34;
        pass


if __name__ == &#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyshopper.shopper.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>data_path: str = 'data/train.tsv', prices_path: str = 'data/prices.tsv')</span>
</code></dt>
<dd>
<div class="desc"><p>Extract, transforms, and loads data for Shopper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Shopping trips data.
Path to .tsv file with four columns of data (without header)
in the order of user_id, item_id, session_id, and quantity.
Each row represents one trip.</dd>
<dt><strong><code>prices_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Prices data.
Path to .tsv file with three columns of data (without header)
in the order of item_id, session_id, and price.
Each row represents the price per item per session.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Joined Pandas DataFrame of shopping trips data and prices data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(data_path: str = DATA_PATH, prices_path: str = PRICES_PATH):
    &#34;&#34;&#34;Extract, transforms, and loads data for Shopper.

    Args:
        data_path (str): 
            Shopping trips data.
            Path to .tsv file with four columns of data (without header)
            in the order of user_id, item_id, session_id, and quantity.
            Each row represents one trip.

        prices_path (str): 
            Prices data.
            Path to .tsv file with three columns of data (without header)
            in the order of item_id, session_id, and price.
            Each row represents the price per item per session.

    Returns:
        Joined Pandas DataFrame of shopping trips data and prices data.
    &#34;&#34;&#34;
    trips = pd.read_csv(data_path,
                        header=None,
                        names=[&#39;user_id&#39;, &#39;item_id&#39;, &#39;session_id&#39;, &#39;quantity&#39;],
                        sep=&#39;\t&#39;)
    prices = pd.read_csv(prices_path,
                         header=None,
                         names=[&#39;item_id&#39;, &#39;session_id&#39;, &#39;price&#39;],
                         sep=&#39;\t&#39;)
    data = pd.merge(trips, prices, on=[&#39;item_id&#39;, &#39;session_id&#39;])
    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyshopper.shopper.Shopper"><code class="flex name class">
<span>class <span class="ident">Shopper</span></span>
<span>(</span><span>data: pandas.core.frame.DataFrame, K: int = 50, price_dim: int = 10, price_dtype: str = 'float32', rho_var: float = 1, alpha_var: float = 1, lambda_var: float = 1, theta_var: float = 1, delta_var: float = 0.01, mu_var: float = 0.01, gamma_rate: float = 1000, gamma_shape: float = 100, beta_rate: float = 1000, beta_shape: float = 100)</span>
</code></dt>
<dd>
<div class="desc"><p>Shopper implementation.</p>
<p>Let T = number of trips; U = number of users;
C = number of items; and W = number of weeks.</p>
<p>Note: model currently only supports ordered baskets.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Pandas DataFrame</code></dt>
<dd>Observed trips data (number of trips by 4).
DataFrame with columns: user_id, item_id, session_id, and price.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>PyMC3 Model</code></dt>
<dd>Shopper model.</dd>
</dl>
<p>Intialises Shopper instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Pandas DataFrame</code></dt>
<dd>Observed trips data (number of trips by 4).
DataFrame with columns: user_id, item_id, session_id,
and price.</dd>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of latent factors for alpha_c, rho_c, and theta_u;
defaults to 50.</dd>
<dt><strong><code>price_dim</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of latent factors for price vectors gamma_u and beta_c;
defaults to 10.</dd>
<dt><strong><code>price_dtype</code></strong> :&ensp;<code>str</code></dt>
<dd>The datatype used for prices; defaults to float32.</dd>
<dt><strong><code>rho_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over rho_c; defaults to 1.</dd>
<dt><strong><code>alpha_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over alpha_c; defaults to 1.</dd>
<dt><strong><code>theta_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over theta_u; defaults to 1.</dd>
<dt><strong><code>lambda_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over lambda_c; defaults to 1.</dd>
<dt><strong><code>delta_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over delta_w; defaults to 0.01.</dd>
<dt><strong><code>mu_var</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior variance over mu_c; defaults to 0.01.</dd>
<dt><strong><code>gamma_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior rate over gamma_u; defaults to 1000.</dd>
<dt><strong><code>gamma_shape</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior shape over gamma_u; defaults to 100.</dd>
<dt><strong><code>beta_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior rate over beta_c; defaults to 1000.</dd>
<dt><strong><code>beta_shape</code></strong> :&ensp;<code>float</code></dt>
<dd>Prior shape over beta_c; defaults to 100.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shopper:
    &#34;&#34;&#34;Shopper implementation.

    Let T = number of trips; U = number of users;
    C = number of items; and W = number of weeks.

    Note: model currently only supports ordered baskets.

    Attributes:
        data (Pandas DataFrame): 
            Observed trips data (number of trips by 4).
            DataFrame with columns: user_id, item_id, session_id, and price.

        model (PyMC3 Model): 
            Shopper model.
    &#34;&#34;&#34;
    def __init__(self,
                 data: pd.DataFrame,
                 K: int = 50,
                 price_dim: int = 10,
                 price_dtype: str = &#39;float32&#39;,
                 rho_var: float = 1,
                 alpha_var: float = 1,
                 lambda_var: float = 1,
                 theta_var: float = 1,
                 delta_var: float = 0.01,
                 mu_var: float = 0.01,
                 gamma_rate: float = 1000,
                 gamma_shape: float = 100,
                 beta_rate: float = 1000,
                 beta_shape: float = 100):
        &#34;&#34;&#34;Intialises Shopper instance.

        Args:
            data (Pandas DataFrame): 
                Observed trips data (number of trips by 4).
                DataFrame with columns: user_id, item_id, session_id, 
                and price.

            K (int): 
                Number of latent factors for alpha_c, rho_c, and theta_u;
                defaults to 50.

            price_dim (int): 
                Number of latent factors for price vectors gamma_u and beta_c;
                defaults to 10.

            price_dtype (str): 
                The datatype used for prices; defaults to float32.

            rho_var (float): 
                Prior variance over rho_c; defaults to 1.

            alpha_var (float): 
                Prior variance over alpha_c; defaults to 1.

            theta_var (float): 
                Prior variance over theta_u; defaults to 1.

            lambda_var (float): 
                Prior variance over lambda_c; defaults to 1.

            delta_var (float): 
                Prior variance over delta_w; defaults to 0.01.

            mu_var (float): 
                Prior variance over mu_c; defaults to 0.01.

            gamma_rate (float): 
                Prior rate over gamma_u; defaults to 1000.

            gamma_shape (float): 
                Prior shape over gamma_u; defaults to 100.

            beta_rate (float): 
                Prior rate over beta_c; defaults to 1000.

            beta_shape (float): 
                Prior shape over beta_c; defaults to 100.
        &#34;&#34;&#34;
        # Set data
        self.data = data

        # Number of items
        C = data[&#39;item_id&#39;].nunique()
        # Number of users
        U = data[&#39;user_id&#39;].nunique()

        # Get preprocessed data variables
        data_vars = _prepare_data(data)

        logging.info(&#39;Building the Shopper model...&#39;)
        with pm.Model() as shopper:
            # Data
            prices = pm.Data(&#39;prices&#39;, data_vars[&#39;prices&#39;])
            order = pm.Data(&#39;order&#39;, data_vars[&#39;order&#39;])
            sf = pm.Data(&#39;sf&#39;, data_vars[&#39;sf&#39;])
            obs_idx = pm.Data(&#39;obs_idx&#39;, data_vars[&#39;obs_idx&#39;])
            items_idx = pm.Data(&#39;items_idx&#39;, data_vars[&#39;items_idx&#39;])
            users_idx = pm.Data(&#39;users_idx&#39;, data_vars[&#39;users_idx&#39;])
            labels = pm.Data(&#39;labels&#39;, data_vars[&#39;labels&#39;])

            # Latent variables
            # per item interaction coefficients
            rho_c = pm.Normal(&#39;rho_c&#39;,
                              mu=0,
                              sigma=rho_var,
                              shape=(C, K),
                              dtype=&#39;float32&#39;)
            # per item attributes
            alpha_c = pm.Normal(&#39;alpha_c&#39;,
                                mu=0,
                                sigma=alpha_var,
                                shape=(C, K),
                                dtype=&#39;float32&#39;)
            # per user preferences
            theta_u = pm.Normal(&#39;theta_u&#39;,
                                mu=0,
                                sigma=theta_var,
                                shape=(U, K),
                                dtype=&#39;float32&#39;)
            # per item popularity
            lambda_c = pm.Normal(&#39;lambda_c&#39;,
                                 mu=0,
                                 sigma=lambda_var,
                                 shape=C,
                                 dtype=&#39;float32&#39;)
            # per user price sensitivities
            gamma_u = pm.Gamma(&#39;gamma_u&#39;,
                               beta=gamma_rate,
                               alpha=gamma_shape,
                               shape=(U, price_dim),
                               dtype=&#39;float32&#39;)
            # per item price sensitivities
            beta_c = pm.Gamma(&#39;beta_c&#39;,
                              beta=beta_rate,
                              alpha=beta_shape,
                              shape=(C, price_dim),
                              dtype=&#39;float32&#39;)

            # Baseline utility per item per user:
            # Item popularity + Consumer Preferences - Price Effects
            # Note: variation comes from customer index and item prices
            psi_tc = tt.vector(&#39;psi_tc&#39;)
            psi_tc = lambda_c[items_idx] +\
                pm.math.dot(theta_u[users_idx], alpha_c[items_idx].T) -\
                pm.math.dot(gamma_u[users_idx], beta_c[items_idx].T) *\
                np.log(prices).astype(price_dtype)

            # sum^{i-1}_j [alpha_{y_tj}]
            def basket_items_attr(omega_prev, idx, alpha_c, order):
                # If first item in basket
                if tt.eq(order[idx], 0):
                    # No price-attributes interaction effects
                    omega_ti = tt.zeros(K)
                else:
                    omega_ti = omega_prev + alpha_c[idx-1]
                return omega_ti

            # omega_ti initial value
            omega_0 = tt.zeros(K)
            omega_ti = tt.vector(&#39;omega_ti&#39;)
            omega_ti, updates = theano.scan(fn=basket_items_attr,
                                            outputs_info=omega_0,
                                            non_sequences=[obs_idx,
                                                           alpha_c,
                                                           order],
                                            n_steps=obs_idx.shape[0])
            # Mean utility per basket per item
            Psi_tci = tt.vector(&#39;Psi_tci&#39;)
            Psi_tci = psi_tc + pm.math.dot(rho_c[items_idx],
                                           omega_ti[obs_idx-1].T)*sf[obs_idx]

            # Softmax likelihood p(y_ti = c | y_t0, y_t1, ..., y_ti-1)
            p = pm.Deterministic(&#39;p&#39;, tt.nnet.softmax(Psi_tci))
            y = pm.Categorical(&#39;y&#39;, p=p, observed=labels)

        logging.info(&#34;Done building the Shopper model.&#34;)
        # Set shopper to model attribute
        self.model = shopper

    def fit(self,
            N,
            method=&#39;ADVI&#39;,
            step=None,
            diff=&#39;relative&#39;,
            return_inferencedata=True,
            random_seed=42,
            **kwargs):
        &#34;&#34;&#34;Estimate parameters using Bayesian inference.
        Returns ShopperResults instance.

        Args:
            N (int): 
                Number of draws (MCMC) or iterations (ADVI).

            method (str): 
              - MCMC -- Monte Carlo Markov Chains
              - ADVI -- Automatic Differentiation Variational Inference

            diff (str): 
                Requires method to be ADVI. The difference type used
                to check convergence in the mean of the ADVI approximation

            step (function or iterable of functions):
                Requires method to be MCMC.
                A step function or collection of functions;
                defaults None (which uses the NUTS step method).

            return_inferencedata (bool): 
                Requires method to be MCMC.
                If True, returns arviz.InferenceData object.
                Otherwise, returns MultiTrace.InferenceData object.
                Defaults to True.

            random_seed (int): 
                Random seed; defaults to 42.
        &#34;&#34;&#34;
        model = self.model
        with model:
            if method == &#39;ADVI&#39;:
                callback = CheckParametersConvergence(diff=diff)
                res = pm.fit(n=N,
                             method=&#39;advi&#39;,
                             callbacks=[callback])
            else:
                res = pm.sample(draws=N,
                                step=step,
                                return_inferencedata=True,
                                random_seed=random_seed)
        return ShopperResults(model, res)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyshopper.shopper.Shopper.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, N, method='ADVI', step=None, diff='relative', return_inferencedata=True, random_seed=42, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate parameters using Bayesian inference.
Returns ShopperResults instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of draws (MCMC) or iterations (ADVI).</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>
<ul>
<li>MCMC &ndash; Monte Carlo Markov Chains</li>
<li>ADVI &ndash; Automatic Differentiation Variational Inference</li>
</ul>
</dd>
<dt><strong><code>diff</code></strong> :&ensp;<code>str</code></dt>
<dd>Requires method to be ADVI. The difference type used
to check convergence in the mean of the ADVI approximation</dd>
</dl>
<p>step (function or iterable of functions):
Requires method to be MCMC.
A step function or collection of functions;
defaults None (which uses the NUTS step method).</p>
<dl>
<dt><strong><code>return_inferencedata</code></strong> :&ensp;<code>bool</code></dt>
<dd>Requires method to be MCMC.
If True, returns arviz.InferenceData object.
Otherwise, returns MultiTrace.InferenceData object.
Defaults to True.</dd>
<dt><strong><code>random_seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Random seed; defaults to 42.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self,
        N,
        method=&#39;ADVI&#39;,
        step=None,
        diff=&#39;relative&#39;,
        return_inferencedata=True,
        random_seed=42,
        **kwargs):
    &#34;&#34;&#34;Estimate parameters using Bayesian inference.
    Returns ShopperResults instance.

    Args:
        N (int): 
            Number of draws (MCMC) or iterations (ADVI).

        method (str): 
          - MCMC -- Monte Carlo Markov Chains
          - ADVI -- Automatic Differentiation Variational Inference

        diff (str): 
            Requires method to be ADVI. The difference type used
            to check convergence in the mean of the ADVI approximation

        step (function or iterable of functions):
            Requires method to be MCMC.
            A step function or collection of functions;
            defaults None (which uses the NUTS step method).

        return_inferencedata (bool): 
            Requires method to be MCMC.
            If True, returns arviz.InferenceData object.
            Otherwise, returns MultiTrace.InferenceData object.
            Defaults to True.

        random_seed (int): 
            Random seed; defaults to 42.
    &#34;&#34;&#34;
    model = self.model
    with model:
        if method == &#39;ADVI&#39;:
            callback = CheckParametersConvergence(diff=diff)
            res = pm.fit(n=N,
                         method=&#39;advi&#39;,
                         callbacks=[callback])
        else:
            res = pm.sample(draws=N,
                            step=step,
                            return_inferencedata=True,
                            random_seed=random_seed)
    return ShopperResults(model, res)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyshopper.shopper.ShopperResults"><code class="flex name class">
<span>class <span class="ident">ShopperResults</span></span>
<span>(</span><span>model, res)</span>
</code></dt>
<dd>
<div class="desc"><p>Results class for a fitted Shopper model.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>PyMC3 Model</code></dt>
<dd>Shopper model.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>PyMC3 results instance</code></dt>
<dd>If MCMC, then requires arviz.InferenceData or
MultiTrace.InferenceData. Else if ADVI, then
requires pymc3.variational.opvi.Approximation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShopperResults:
    &#34;&#34;&#34;Results class for a fitted Shopper model.

    Attributes:
        model (PyMC3 Model): 
            Shopper model.

        res (PyMC3 results instance): 
            If MCMC, then requires arviz.InferenceData or
            MultiTrace.InferenceData. Else if ADVI, then
            requires pymc3.variational.opvi.Approximation.
    &#34;&#34;&#34;
    def __init__(self, model, res):
        self.model = model
        self.res = res

    def summary(self, **kwargs):
        &#34;&#34;&#34;Returns text-based output of common posterior statistics.

        Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
        to be set in kwargs if model was fitted with ADVI.
        &#34;&#34;&#34;
        res = self.res
        if &#39;variational&#39; in str(type(res)):
            logging.info(&#39;Sampling from posterior distribution...&#39;)
            trace = res.sample(draws=kwargs[&#39;draws&#39;])
            logging.info(&#39;Sampling complete.&#39;)
            logging.info(&#39;Computing posterior statistics...&#39;)
            summary = az.summary(trace, kind=&#39;stats&#39;)
        else:
            summary = az.summary(res)
        return summary

    def trace_plot(self, **kwargs):
        &#34;&#34;&#34;Returns the trace plot.

        Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
        to be set in kwargs if model was fitted with ADVI.
        &#34;&#34;&#34;
        res = self.res
        if &#39;variational&#39; in str(type(res)):
            logging.info(&#39;Sampling from posterior distribution...&#39;)
            trace = res.sample(draws=kwargs[&#39;draws&#39;])
            logging.info(&#39;Sampling complete.&#39;)
            plot = az.plot_trace(trace)
        else:
            plot = az.plot_trace(res)
        return plot

    def rhat(self):
        &#34;&#34;&#34;Returns the Gelman-Rubin statistic.

        Requires the Shopper model to be fitted with
        MCMC sampling.
        &#34;&#34;&#34;
        return az.summary(self.res)

    def energy_plot(self):
        &#34;&#34;&#34;Returns energy plot to check for convergence.
        Commonly used for high-dimensional models where it
        is too cumbersome to examine all parameter&#39;s traces.

        Requires the Shopper model to be fitted with
        MCMC sampling.
        &#34;&#34;&#34;
        return az.plot_energy(self.res)

    def elbo_plot(self):
        &#34;&#34;&#34;Returns trace plot of ADVI&#39;s objective function (ELBO).

        Requires the Shopper model to be fitted with ADVI.
        &#34;&#34;&#34;
        fig = plt.figure()
        plt.plot(self.res.hist)
        plt.ylabel(&#39;ELBO&#39;)
        plt.xlabel(&#39;n iterations&#39;)
        return fig

    def predict(self, data, random_seed=42, **kwargs):
        &#34;&#34;&#34;Returns predicted probabilities of outcomes for samples in X.
        &#34;&#34;&#34;
        model = self.model
        res = self.res
        data_vars = _prepare_data(data)
        with model:
            # Pass new values to model
            pm.set_data(data_vars)
            # Use the updated values and
            # predict outcomes and probabilities
            if &#39;variational&#39; in str(type(res)):
                logging.info(&#39;Sampling from posterior distribution...&#39;)
                trace = res.sample(draws=kwargs[&#39;draws&#39;])
                logging.info(&#39;Sampling complete.&#39;)
                posterior_predictive = pm.sample_posterior_predictive(
                    trace,
                    var_names=[&#39;y&#39;],
                    random_seed=random_seed
                )
            else:
                posterior_predictive = pm.sample_posterior_predictive(
                    res,
                    var_names=[&#39;y&#39;],
                    random_seed=random_seed
                )
        return posterior_predictive[&#39;y&#39;]

    def score(self, data):
        &#34;&#34;&#34;Returns the mean accuracy on the given test data and labels.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyshopper.shopper.ShopperResults.elbo_plot"><code class="name flex">
<span>def <span class="ident">elbo_plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns trace plot of ADVI's objective function (ELBO).</p>
<p>Requires the Shopper model to be fitted with ADVI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elbo_plot(self):
    &#34;&#34;&#34;Returns trace plot of ADVI&#39;s objective function (ELBO).

    Requires the Shopper model to be fitted with ADVI.
    &#34;&#34;&#34;
    fig = plt.figure()
    plt.plot(self.res.hist)
    plt.ylabel(&#39;ELBO&#39;)
    plt.xlabel(&#39;n iterations&#39;)
    return fig</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.energy_plot"><code class="name flex">
<span>def <span class="ident">energy_plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns energy plot to check for convergence.
Commonly used for high-dimensional models where it
is too cumbersome to examine all parameter's traces.</p>
<p>Requires the Shopper model to be fitted with
MCMC sampling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def energy_plot(self):
    &#34;&#34;&#34;Returns energy plot to check for convergence.
    Commonly used for high-dimensional models where it
    is too cumbersome to examine all parameter&#39;s traces.

    Requires the Shopper model to be fitted with
    MCMC sampling.
    &#34;&#34;&#34;
    return az.plot_energy(self.res)</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, data, random_seed=42, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns predicted probabilities of outcomes for samples in X.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, data, random_seed=42, **kwargs):
    &#34;&#34;&#34;Returns predicted probabilities of outcomes for samples in X.
    &#34;&#34;&#34;
    model = self.model
    res = self.res
    data_vars = _prepare_data(data)
    with model:
        # Pass new values to model
        pm.set_data(data_vars)
        # Use the updated values and
        # predict outcomes and probabilities
        if &#39;variational&#39; in str(type(res)):
            logging.info(&#39;Sampling from posterior distribution...&#39;)
            trace = res.sample(draws=kwargs[&#39;draws&#39;])
            logging.info(&#39;Sampling complete.&#39;)
            posterior_predictive = pm.sample_posterior_predictive(
                trace,
                var_names=[&#39;y&#39;],
                random_seed=random_seed
            )
        else:
            posterior_predictive = pm.sample_posterior_predictive(
                res,
                var_names=[&#39;y&#39;],
                random_seed=random_seed
            )
    return posterior_predictive[&#39;y&#39;]</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.rhat"><code class="name flex">
<span>def <span class="ident">rhat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Gelman-Rubin statistic.</p>
<p>Requires the Shopper model to be fitted with
MCMC sampling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rhat(self):
    &#34;&#34;&#34;Returns the Gelman-Rubin statistic.

    Requires the Shopper model to be fitted with
    MCMC sampling.
    &#34;&#34;&#34;
    return az.summary(self.res)</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mean accuracy on the given test data and labels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score(self, data):
    &#34;&#34;&#34;Returns the mean accuracy on the given test data and labels.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns text-based output of common posterior statistics.</p>
<p>Requires 'draws' (sample size to be drawn from posterior distribution)
to be set in kwargs if model was fitted with ADVI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(self, **kwargs):
    &#34;&#34;&#34;Returns text-based output of common posterior statistics.

    Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
    to be set in kwargs if model was fitted with ADVI.
    &#34;&#34;&#34;
    res = self.res
    if &#39;variational&#39; in str(type(res)):
        logging.info(&#39;Sampling from posterior distribution...&#39;)
        trace = res.sample(draws=kwargs[&#39;draws&#39;])
        logging.info(&#39;Sampling complete.&#39;)
        logging.info(&#39;Computing posterior statistics...&#39;)
        summary = az.summary(trace, kind=&#39;stats&#39;)
    else:
        summary = az.summary(res)
    return summary</code></pre>
</details>
</dd>
<dt id="pyshopper.shopper.ShopperResults.trace_plot"><code class="name flex">
<span>def <span class="ident">trace_plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the trace plot.</p>
<p>Requires 'draws' (sample size to be drawn from posterior distribution)
to be set in kwargs if model was fitted with ADVI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace_plot(self, **kwargs):
    &#34;&#34;&#34;Returns the trace plot.

    Requires &#39;draws&#39; (sample size to be drawn from posterior distribution)
    to be set in kwargs if model was fitted with ADVI.
    &#34;&#34;&#34;
    res = self.res
    if &#39;variational&#39; in str(type(res)):
        logging.info(&#39;Sampling from posterior distribution...&#39;)
        trace = res.sample(draws=kwargs[&#39;draws&#39;])
        logging.info(&#39;Sampling complete.&#39;)
        plot = az.plot_trace(trace)
    else:
        plot = az.plot_trace(res)
    return plot</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyshopper" href="index.html">pyshopper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyshopper.shopper.load_data" href="#pyshopper.shopper.load_data">load_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyshopper.shopper.Shopper" href="#pyshopper.shopper.Shopper">Shopper</a></code></h4>
<ul class="">
<li><code><a title="pyshopper.shopper.Shopper.fit" href="#pyshopper.shopper.Shopper.fit">fit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyshopper.shopper.ShopperResults" href="#pyshopper.shopper.ShopperResults">ShopperResults</a></code></h4>
<ul class="two-column">
<li><code><a title="pyshopper.shopper.ShopperResults.elbo_plot" href="#pyshopper.shopper.ShopperResults.elbo_plot">elbo_plot</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.energy_plot" href="#pyshopper.shopper.ShopperResults.energy_plot">energy_plot</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.predict" href="#pyshopper.shopper.ShopperResults.predict">predict</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.rhat" href="#pyshopper.shopper.ShopperResults.rhat">rhat</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.score" href="#pyshopper.shopper.ShopperResults.score">score</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.summary" href="#pyshopper.shopper.ShopperResults.summary">summary</a></code></li>
<li><code><a title="pyshopper.shopper.ShopperResults.trace_plot" href="#pyshopper.shopper.ShopperResults.trace_plot">trace_plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>